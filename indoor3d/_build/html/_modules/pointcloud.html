
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pointcloud &#8212; indoor3d 0 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">indoor3d 0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pointcloud</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pointcloud</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">In this module we embed all the functions related to general geometry questions.</span>
<span class="sd">We use the module `vg &lt;https://pypi.org/project/vg/&gt;`_, which is useful for some operations</span>
<span class="sd">with vectors. The *plane_model* refers to four values (a, b, c, d) which</span>
<span class="sd">corresponds to the equation form Ax + By + Cz + D = 0. The normal to a plane is (A, B, C).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">open3d</span> <span class="k">as</span> <span class="nn">o3d</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Point3D</span><span class="p">,</span> <span class="n">Plane</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">NamedTuple</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Type</span>
<span class="kn">import</span> <span class="nn">plane</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">ConvexHull</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">default_rng</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>

<span class="n">numeric</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">]</span>

<div class="viewcode-block" id="get_distance_between_pointcloud_and_plane"><a class="viewcode-back" href="../api/pointcloud.get_distance_between_pointcloud_and_plane.html#pointcloud.get_distance_between_pointcloud_and_plane">[docs]</a><span class="k">def</span> <span class="nf">get_distance_between_pointcloud_and_plane</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span> <span class="n">plane</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">PlaneIndoor</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the distance between the pointcloud and the plane.</span>

<span class="sd">    :param pcd: Pointcloud.</span>
<span class="sd">    :type pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param plane: Plane model.</span>
<span class="sd">    :type plane: Type[plane.PlaneIndoor]</span>
<span class="sd">    :return: Distance between the pointcloud and the plane.</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import plane</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; mesh_box = o3d.geometry.TriangleMesh.create_box(width=1.0, height=5.0, depth=1.0)</span>
<span class="sd">        &gt;&gt;&gt; pcd = mesh_box.sample_points_uniformly(number_of_points = 10000, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; plane = plane.PlaneIndoor((1, 1, 1, 1))</span>
<span class="sd">        &gt;&gt;&gt; distance = pointcloud.get_distance_between_pointcloud_and_plane(pcd, plane)</span>
<span class="sd">        &gt;&gt;&gt; distance</span>
<span class="sd">        0.5886230622926497</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">C</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">D</span>
    <span class="n">pcd_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">points_transposed</span> <span class="o">=</span> <span class="n">pcd_points</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">points_transposed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">points_transposed</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">points_transposed</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span> <span class="o">+</span> <span class="n">d</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">))</span></div>




<div class="viewcode-block" id="get_distance_between_pointcloud_and_point"><a class="viewcode-back" href="../api/pointcloud.get_distance_between_pointcloud_and_point.html#pointcloud.get_distance_between_pointcloud_and_point">[docs]</a><span class="k">def</span> <span class="nf">get_distance_between_pointcloud_and_point</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the distance between the pointcloud and the point.</span>

<span class="sd">    :param pcd: Pointcloud.</span>
<span class="sd">    :type pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param point: Point.</span>
<span class="sd">    :type point: np.ndarray</span>
<span class="sd">    :return: Distance between the pointcloud and the point.</span>
<span class="sd">    :rtype: float</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; mesh_box = o3d.geometry.TriangleMesh.create_box(width=1.0, height=5.0, depth=1.0)</span>
<span class="sd">        &gt;&gt;&gt; pcd = mesh_box.sample_points_uniformly(number_of_points = 10000, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; distance = pointcloud.get_distance_between_pointcloud_and_point(pcd, [10, 10, 10])</span>
<span class="sd">        &gt;&gt;&gt; distance</span>
<span class="sd">        13.703526637666375</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pcd_point</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">pcd_point</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">point</span><span class="p">]))</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">pcd</span><span class="o">.</span><span class="n">compute_point_cloud_distance</span><span class="p">(</span><span class="n">pcd_point</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span></div>

<span class="c1">#@profile</span>
<span class="c1"># return the points in the plane, and in the two sides of the plane</span>
<span class="c1"># tolerance is the maximum distance of the points in the plane to the plane</span>
<div class="viewcode-block" id="get_partition_of_pointcloud_by_plane_with_thickness"><a class="viewcode-back" href="../api/pointcloud.get_partition_of_pointcloud_by_plane_with_thickness.html#pointcloud.get_partition_of_pointcloud_by_plane_with_thickness">[docs]</a><span class="k">def</span> <span class="nf">get_partition_of_pointcloud_by_plane_with_thickness</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span>
                                                        <span class="n">plane</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">PlaneIndoor</span><span class="p">],</span>
                                                        <span class="n">plane_thickness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                                                        <span class="n">debug</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">]:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Given a point cloud and a plane, returns the points which are in one side, in the other,</span>
<span class="sd">    or in the plane, if supposed it has some thickness. Such thickness is twice the **plane_thickness**</span>
<span class="sd">    parameter, because it is computed once for each side. It returns three elements:</span>
<span class="sd">    the points in the &quot;positive&quot; set, those such that the signed distance is positive;</span>
<span class="sd">    the points in the &quot;negative&quot; set, those whose signed distance is negative; and the &quot;in_plane&quot; set,</span>
<span class="sd">    those which are closer to the plane that the **plane_thickness** parameter. The elements are returned</span>
<span class="sd">    in a dictionary with &quot;positive&quot;, &quot;negative&quot; and &quot;in_plane&quot; as keys.</span>

<span class="sd">    :param pcd: Pointcloud to be segmented.</span>
<span class="sd">    :type pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param plane_model: Plane to partition the space.</span>
<span class="sd">    :type plane_model: Type[plane.PlaneIndoor]</span>
<span class="sd">    :param plane_thickness: Maximum distance from the plane to be considered for the pointcloud &quot;in_plane&quot;.</span>
<span class="sd">    :type plane_thickness: float</span>
<span class="sd">    :param debug: if debug information is shown, default is False.</span>
<span class="sd">    :type debug: bool</span>
<span class="sd">    :return: Dictionary of pointclouds as values and with three keys: &quot;positive&quot;, &quot;negative&quot; and &quot;in_plane&quot;.</span>
<span class="sd">    :rtype: Dict[str, o3d.geometry.PointCloud]</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import plane</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; # import os</span>
<span class="sd">        &gt;&gt;&gt; # home_dir = os.getenv(&quot;HOME&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # pcd = o3d.io.read_point_cloud(home_dir + &quot;/Github/Lantegi/Code/Open3D/gui/skull.ply&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pcd = o3d.io.read_point_cloud(&quot;Code/Open3D/gui/skull.ply&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plane = plane.PlaneIndoor((0, 0, 1, 0))</span>
<span class="sd">        &gt;&gt;&gt; dict_clouds = pointcloud.get_partition_of_pointcloud_by_plane_with_thickness(pcd, plane, plane_thickness = 10)</span>
<span class="sd">        &gt;&gt;&gt; dict_clouds</span>
<span class="sd">        {&#39;in_plane&#39;: PointCloud with 14374 points., &#39;positive&#39;: PointCloud with 57124 points., &#39;negative&#39;: PointCloud with 61511 points.}</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">in_plane</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">positive</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">negative</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>

    <span class="n">pcd_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">pcd_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span>
    <span class="n">dist</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">get_distance_and_sign_between_plane_and_points</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="n">pcd_points</span><span class="p">)</span>
    <span class="n">list_points_in_plane</span> <span class="o">=</span> <span class="n">pcd_points</span><span class="p">[</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">plane_thickness</span><span class="p">]</span>
    <span class="n">list_colors_in_plane</span> <span class="o">=</span> <span class="n">pcd_colors</span><span class="p">[</span><span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">plane_thickness</span><span class="p">]</span>
    <span class="n">positive_condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">plane_thickness</span><span class="p">,</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">list_points_in_positive</span> <span class="o">=</span> <span class="n">pcd_points</span><span class="p">[</span><span class="n">positive_condition</span><span class="p">]</span>
    <span class="n">list_colors_in_positive</span> <span class="o">=</span> <span class="n">pcd_colors</span><span class="p">[</span><span class="n">positive_condition</span><span class="p">]</span>
    <span class="n">negative_condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">plane_thickness</span><span class="p">,</span> <span class="n">sign</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">list_points_in_negative</span> <span class="o">=</span> <span class="n">pcd_points</span><span class="p">[</span><span class="n">negative_condition</span><span class="p">]</span>
    <span class="n">list_colors_in_negative</span> <span class="o">=</span> <span class="n">pcd_colors</span><span class="p">[</span><span class="n">negative_condition</span><span class="p">]</span>

    <span class="n">in_plane</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">list_points_in_plane</span><span class="p">)</span>
    <span class="n">in_plane</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">list_colors_in_plane</span><span class="p">)</span>
    <span class="n">positive</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">list_points_in_positive</span><span class="p">)</span>
    <span class="n">positive</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">list_colors_in_positive</span><span class="p">)</span>
    <span class="n">negative</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">list_points_in_negative</span><span class="p">)</span>
    <span class="n">negative</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">list_colors_in_negative</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;find_sides_of_plane&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;in_plane&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">in_plane</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;positive&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">positive</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;negative&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">negative</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;in_plane&quot;</span><span class="p">:</span> <span class="n">in_plane</span><span class="p">,</span> <span class="s2">&quot;positive&quot;</span><span class="p">:</span> <span class="n">positive</span><span class="p">,</span> <span class="s2">&quot;negative&quot;</span><span class="p">:</span> <span class="n">negative</span><span class="p">}</span></div>

<span class="c1">#@profile</span>
<div class="viewcode-block" id="get_partition_of_pointcloud_by_quasi_parallel_planes_with_thickness"><a class="viewcode-back" href="../api/pointcloud.get_partition_of_pointcloud_by_quasi_parallel_planes_with_thickness.html#pointcloud.get_partition_of_pointcloud_by_quasi_parallel_planes_with_thickness">[docs]</a><span class="k">def</span> <span class="nf">get_partition_of_pointcloud_by_quasi_parallel_planes_with_thickness</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span>
                                                                        <span class="n">plane_1</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">PlaneIndoor</span><span class="p">],</span>
                                                                        <span class="n">plane_2</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">PlaneIndoor</span><span class="p">],</span>
                                                                        <span class="n">plane_thickness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a point cloud and two parallel (up to some tolerance not defined here) plane models,</span>
<span class="sd">    returns the points which are in plane_1, in plane_2, in one side of both, in the other,</span>
<span class="sd">    or in the middle. The plane is supposed to have some thickness. Such thickness is twice</span>
<span class="sd">    the **plane_thickness** parameter, because it is computed once for each side.</span>
<span class="sd">    It returns five elements: the points in the &quot;in_plane_1&quot; set, those which are closer to the plane</span>
<span class="sd">    that the **tolerance** parameter; same for points in the &quot;in_plane_2&quot; set; the points in the &quot;middle&quot;</span>
<span class="sd">    of the two planes; the points is &quot;one_side&quot;; and the points in the &quot;other_side&quot;. These elements</span>
<span class="sd">    (pointclouds) are returned in a dictionary with &quot;in_plane_1&quot;, &quot;in_plane_2&quot;, &quot;middle&quot;, &quot;one_side&quot;</span>
<span class="sd">    and &quot;other_side&quot; as keys.</span>

<span class="sd">    :param pcd: Pointcloud to be segmented.</span>
<span class="sd">    :type pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param plane_1: Plane model to partition the space.</span>
<span class="sd">    :type plane_1: Type[plane.PlaneIndoor]</span>
<span class="sd">    :param plane_2: Plane model to partition the space.</span>
<span class="sd">    :type plane_2: Type[plane.PlaneIndoor]</span>
<span class="sd">    :param plane_thickness: Maximum distance from the plane to be considered for the pointcloud &quot;in_plane&quot;.</span>
<span class="sd">    :type plane_thickness: float</span>
<span class="sd">    :return: Dictionary of pointclouds as values and with five keys: &quot;in_plane_1&quot;, &quot;in_plane_2&quot;, &quot;middle&quot;, &quot;one_side&quot; and &quot;other_side&quot;.</span>
<span class="sd">    :rtype: Dict[str, o3d.geometry.PointCloud]</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import plane</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; # import os</span>
<span class="sd">        &gt;&gt;&gt; # home_dir = os.getenv(&quot;HOME&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # pcd = o3d.io.read_point_cloud(home_dir + &quot;/Github/Lantegi/Code/Open3D/gui/skull.ply&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pcd = o3d.io.read_point_cloud(&quot;Code/Open3D/gui/skull.ply&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plane_1 = plane.PlaneIndoor((0, 0, 1, 0))</span>
<span class="sd">        &gt;&gt;&gt; plane_2 = plane.PlaneIndoor((0, 0, 1, 30))</span>
<span class="sd">        &gt;&gt;&gt; dict_clouds = pointcloud.get_partition_of_pointcloud_by_quasi_parallel_planes_with_thickness(pcd, plane_1, plane_2, plane_thickness = 5)</span>
<span class="sd">        &gt;&gt;&gt; dict_clouds</span>
<span class="sd">        {&#39;one_side&#39;: PointCloud with 60690 points., &#39;other_side&#39;: PointCloud with 42574 points., &#39;middle&#39;: PointCloud with 14660 points., &#39;in_plane_1&#39;: PointCloud with 7192 points., &#39;in_plane_2&#39;: PointCloud with 7893 points.}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># first, we find the space partitions by each plane</span>
    <span class="n">dict_clouds_1</span> <span class="o">=</span> <span class="n">get_partition_of_pointcloud_by_plane_with_thickness</span><span class="p">(</span><span class="n">pcd</span><span class="p">,</span> <span class="n">plane_1</span><span class="p">,</span> <span class="n">plane_thickness</span><span class="o">=</span><span class="n">plane_thickness</span><span class="p">)</span>
    <span class="n">dict_clouds_2</span> <span class="o">=</span> <span class="n">get_partition_of_pointcloud_by_plane_with_thickness</span><span class="p">(</span><span class="n">pcd</span><span class="p">,</span> <span class="n">plane_2</span><span class="p">,</span> <span class="n">plane_thickness</span><span class="o">=</span><span class="n">plane_thickness</span><span class="p">)</span>
    <span class="n">point_in_plane_2</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">get_point_on_plane_closest_to_the_origin</span><span class="p">(</span><span class="n">plane_2</span><span class="p">)</span>
    <span class="c1"># we look for the sign of plane_2 with respect to plane_1</span>
    <span class="n">distance</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">get_distance_and_sign_between_plane_and_point</span><span class="p">(</span><span class="n">plane_1</span><span class="p">,</span> <span class="n">point_in_plane_2</span><span class="p">)</span>
    <span class="c1"># and then we divide the space according to that sign; the &quot;good half&quot; is the same sign than plane_2</span>
    <span class="k">if</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">one_side</span><span class="p">,</span> <span class="n">next_pcd</span> <span class="o">=</span> <span class="n">dict_clouds_1</span><span class="p">[</span><span class="s2">&quot;negative&quot;</span><span class="p">],</span> <span class="n">dict_clouds_1</span><span class="p">[</span><span class="s2">&quot;positive&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">one_side</span><span class="p">,</span> <span class="n">next_pcd</span> <span class="o">=</span> <span class="n">dict_clouds_1</span><span class="p">[</span><span class="s2">&quot;positive&quot;</span><span class="p">],</span> <span class="n">dict_clouds_1</span><span class="p">[</span><span class="s2">&quot;negative&quot;</span><span class="p">]</span>
    <span class="n">point_in_plane_1</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">get_point_on_plane_closest_to_the_origin</span><span class="p">(</span><span class="n">plane_1</span><span class="p">)</span>
    <span class="c1"># we look for the sign of plane_1 with respect to plane_2</span>
    <span class="n">distance</span><span class="p">,</span> <span class="n">sign</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">get_distance_and_sign_between_plane_and_point</span><span class="p">(</span><span class="n">plane_2</span><span class="p">,</span> <span class="n">point_in_plane_1</span><span class="p">)</span>
    <span class="c1"># new partition of the previous &quot;good half&quot;</span>
    <span class="n">dict_clouds_2</span> <span class="o">=</span> <span class="n">get_partition_of_pointcloud_by_plane_with_thickness</span><span class="p">(</span><span class="n">next_pcd</span><span class="p">,</span> <span class="n">plane_2</span><span class="p">,</span> <span class="n">plane_thickness</span><span class="o">=</span><span class="n">plane_thickness</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sign</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">other_side</span><span class="p">,</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">dict_clouds_2</span><span class="p">[</span><span class="s2">&quot;negative&quot;</span><span class="p">],</span> <span class="n">dict_clouds_2</span><span class="p">[</span><span class="s2">&quot;positive&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">other_side</span><span class="p">,</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">dict_clouds_2</span><span class="p">[</span><span class="s2">&quot;positive&quot;</span><span class="p">],</span> <span class="n">dict_clouds_2</span><span class="p">[</span><span class="s2">&quot;negative&quot;</span><span class="p">]</span>
    <span class="n">dict_clouds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">dict_clouds</span><span class="p">[</span><span class="s2">&quot;one_side&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">one_side</span>
    <span class="n">dict_clouds</span><span class="p">[</span><span class="s2">&quot;other_side&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_side</span>
    <span class="n">dict_clouds</span><span class="p">[</span><span class="s2">&quot;middle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">middle</span>
    <span class="n">dict_clouds</span><span class="p">[</span><span class="s2">&quot;in_plane_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_clouds_1</span><span class="p">[</span><span class="s2">&quot;in_plane&quot;</span><span class="p">]</span>
    <span class="n">dict_clouds</span><span class="p">[</span><span class="s2">&quot;in_plane_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dict_clouds_2</span><span class="p">[</span><span class="s2">&quot;in_plane&quot;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dict_clouds</span></div>

<div class="viewcode-block" id="check_points_inside_convex_hull"><a class="viewcode-back" href="../api/pointcloud.check_points_inside_convex_hull.html#pointcloud.check_points_inside_convex_hull">[docs]</a><span class="k">def</span> <span class="nf">check_points_inside_convex_hull</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">hull</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks if the points in the list are inside the convex hull. It returns True in that case,</span>
<span class="sd">    False otherwise. It does not work ok with points just in the hull.</span>

<span class="sd">    :param points: List of points.</span>
<span class="sd">    :type points: Iterable[Iterable[float]]</span>
<span class="sd">    :param hull: Convex hull to check against.</span>
<span class="sd">    :param hull: scipy.spatial.ConvexHull</span>
<span class="sd">    :return: List of booleans, one for each point, True if the point lies inside the convex hull, False otherwise.</span>
<span class="sd">    :rtype: np.ndarray</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial import ConvexHull</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[-2.65908417, 1.66316594, -12.05967958], [0.0459558, 1.72705225, -5.76867598], [ -6.27471812,   1.66093731,  -3.02014327], [-9.10951204, 1.59325844, -9.76566801], [-2.56569358, -1.59892799, -12.08053818], [0.1378323 , -1.63325758, -5.80021574], [-6.33750632, -1.6103617 , -2.9846542], [-9.17057479, -1.57383548, -9.73196329], [-4.49166262, 0.0285039, -7.65144228]])</span>
<span class="sd">        &gt;&gt;&gt; hull = ConvexHull(points)</span>
<span class="sd">        &gt;&gt;&gt; pointcloud.check_points_inside_convex_hull([(points[2] + points[3])/2], hull)</span>
<span class="sd">        array([ True])</span>
<span class="sd">        &gt;&gt;&gt; pointcloud.check_points_inside_convex_hull([[0,0,0]], hull)</span>
<span class="sd">        array([False])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">hull</span><span class="o">.</span><span class="n">equations</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">hull</span><span class="o">.</span><span class="n">equations</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">((</span><span class="n">A</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">points</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_pointcloud_after_substracting_convex_hull"><a class="viewcode-back" href="../api/pointcloud.get_pointcloud_after_substracting_convex_hull.html#pointcloud.get_pointcloud_after_substracting_convex_hull">[docs]</a><span class="k">def</span> <span class="nf">get_pointcloud_after_substracting_convex_hull</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span> <span class="n">substract</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">qhull</span><span class="o">.</span><span class="n">ConvexHull</span><span class="p">,</span>
                                                  <span class="n">reverse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Substracts a hull from a pointcloud. It removes all the points of the pointcloud that are</span>
<span class="sd">    inside the convex hull. The points in the surface of the hull remain. If *reverse* is True, it</span>
<span class="sd">    removes the points outside the convex hull.</span>

<span class="sd">    :param pcd: Pointcloud to process.</span>
<span class="sd">    :type pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param substract: Convex hull for checking if it is inside it.</span>
<span class="sd">    :type substract: scipy.spatial.qhull.ConvexHull</span>
<span class="sd">    :param reverse: If True, remove the points outside the hull. Default value is False.</span>
<span class="sd">    :type reverse: bool</span>
<span class="sd">    :return: Result of substracting the hull to the pointcloud</span>
<span class="sd">    :rtype: o3d.geometry.PointCloud</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; from scipy.spatial import ConvexHull</span>
<span class="sd">        &gt;&gt;&gt; mesh_box = o3d.geometry.TriangleMesh.create_box(width=1.0, height=5.0, depth=1.0)</span>
<span class="sd">        &gt;&gt;&gt; pcd = mesh_box.sample_points_uniformly(number_of_points = 10000, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; # pcd.paint_uniform_color((0,0,1))</span>
<span class="sd">        &gt;&gt;&gt; points = [[0,0,0], [0,0,1], [0,1,0], [0,1,1], [1,0,0], [1,0,1], [1,1,0], [1,1,1]]</span>
<span class="sd">        &gt;&gt;&gt; hull = ConvexHull(points)</span>
<span class="sd">        &gt;&gt;&gt; pcd_minus_hull = pointcloud.get_pointcloud_after_substracting_convex_hull(pcd, hull)</span>
<span class="sd">        &gt;&gt;&gt; pcd_inside_hull = pointcloud.get_pointcloud_after_substracting_convex_hull(pcd, hull, reverse = True)</span>
<span class="sd">        &gt;&gt;&gt; # pcd_inside_hull.paint_uniform_color((1,0,0))</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([pcd_inside_hull, pcd_minus_hull])</span>
<span class="sd">        &gt;&gt;&gt; pcd_minus_hull</span>
<span class="sd">        PointCloud with 7778 points.</span>
<span class="sd">        &gt;&gt;&gt; pcd_inside_hull</span>
<span class="sd">        PointCloud with 2222 points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pcd_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">points_outside_hull</span> <span class="o">=</span> <span class="n">pcd_points</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">check_points_inside_convex_hull</span><span class="p">(</span><span class="n">pcd_points</span><span class="p">,</span> <span class="n">substract</span><span class="p">))]</span>
        <span class="n">pcd_outside</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
        <span class="n">pcd_outside</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">points_outside_hull</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pcd_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span>
            <span class="n">colors_outside_hull</span> <span class="o">=</span> <span class="n">pcd_colors</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">check_points_inside_convex_hull</span><span class="p">(</span><span class="n">pcd_points</span><span class="p">,</span> <span class="n">substract</span><span class="p">))]</span>
            <span class="n">pcd_outside</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">colors_outside_hull</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pcd_outside</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">points_inside_hull</span> <span class="o">=</span> <span class="n">pcd_points</span><span class="p">[</span><span class="n">check_points_inside_convex_hull</span><span class="p">(</span><span class="n">pcd_points</span><span class="p">,</span> <span class="n">substract</span><span class="p">)]</span>
        <span class="n">pcd_inside</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
        <span class="n">pcd_inside</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">points_inside_hull</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pcd_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span>
            <span class="n">colors_inside_hull</span> <span class="o">=</span> <span class="n">pcd_colors</span><span class="p">[</span><span class="n">check_points_inside_convex_hull</span><span class="p">(</span><span class="n">pcd_points</span><span class="p">,</span> <span class="n">substract</span><span class="p">)]</span>
            <span class="n">pcd_inside</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">colors_inside_hull</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pcd_inside</span></div>

<div class="viewcode-block" id="get_pointcloud_uniform_sample_inside_convex_hull_of_pointcloud"><a class="viewcode-back" href="../api/pointcloud.get_pointcloud_uniform_sample_inside_convex_hull_of_pointcloud.html#pointcloud.get_pointcloud_uniform_sample_inside_convex_hull_of_pointcloud">[docs]</a><span class="k">def</span> <span class="nf">get_pointcloud_uniform_sample_inside_convex_hull_of_pointcloud</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                                   <span class="n">color</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a pointcloud that is composed of points sampled inside the convex hull of another pointcloud.</span>

<span class="sd">    :param pcd: The input pointcloud.</span>
<span class="sd">    :type pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param size: Number of points to be sampled.</span>
<span class="sd">    :type size: int</span>
<span class="sd">    :param seed: Seed of the random number generator.</span>
<span class="sd">    :type seed: Optional[int]</span>
<span class="sd">    :param color: Color of the sampled pointcloud. Defaults to None, green inside the code.</span>
<span class="sd">    :type color: Tuple[float, float, float]</span>
<span class="sd">    :return: The sampled pointcloud.</span>
<span class="sd">    :rtype: o3d.geometry.PointCloud</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[-2.65908417, 1.66316594, -12.05967958], [0.0459558, 1.72705225, -5.76867598], [ -6.27471812,   1.66093731,  -3.02014327], [-9.10951204, 1.59325844, -9.76566801], [-2.56569358, -1.59892799, -12.08053818], [0.1378323 , -1.63325758, -5.80021574], [-6.33750632, -1.6103617 , -2.9846542], [-9.17057479, -1.57383548, -9.73196329], [-4.49166262, 0.0285039, -7.65144228]])</span>
<span class="sd">        &gt;&gt;&gt; pcd = o3d.geometry.PointCloud()</span>
<span class="sd">        &gt;&gt;&gt; pcd.points = o3d.utility.Vector3dVector(points)</span>
<span class="sd">        &gt;&gt;&gt; pcd_inside = pointcloud.get_pointcloud_uniform_sample_inside_convex_hull_of_pointcloud(pcd, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([pcd_inside])</span>
<span class="sd">        &gt;&gt;&gt; pcd_inside.points[0]</span>
<span class="sd">        array([-3.98803751,  0.84332722, -4.3866304 ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">hull</span> <span class="o">=</span> <span class="n">ConvexHull</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">))</span>
    <span class="n">oriented_bounding_box</span> <span class="o">=</span> <span class="n">pcd</span><span class="o">.</span><span class="n">get_oriented_bounding_box</span><span class="p">()</span>
    <span class="n">points_in_oriented_box</span> <span class="o">=</span> <span class="n">get_points_uniform_sampled_inside_oriented_box</span><span class="p">(</span><span class="n">oriented_bounding_box</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">)</span>
    <span class="n">points_inside_hull</span> <span class="o">=</span> <span class="n">points_in_oriented_box</span><span class="p">[</span><span class="n">check_points_inside_convex_hull</span><span class="p">(</span><span class="n">points_in_oriented_box</span><span class="p">,</span> <span class="n">hull</span><span class="p">)]</span>
    <span class="n">pcd_inside</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">pcd_inside</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">points_inside_hull</span><span class="p">)</span>
    <span class="n">pcd_inside</span><span class="o">.</span><span class="n">paint_uniform_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pcd_inside</span></div>

<div class="viewcode-block" id="get_points_uniform_sampled_inside_oriented_box"><a class="viewcode-back" href="../api/pointcloud.get_points_uniform_sampled_inside_oriented_box.html#pointcloud.get_points_uniform_sampled_inside_oriented_box">[docs]</a><span class="k">def</span> <span class="nf">get_points_uniform_sampled_inside_oriented_box</span><span class="p">(</span><span class="n">box</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">OrientedBoundingBox</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an array of points inside the oriented box.</span>

<span class="sd">    :param box: The input oriented box.</span>
<span class="sd">    :type box: o3d.geometry.OrientedBoundingBox</span>
<span class="sd">    :param size: Number of points to be sampled.</span>
<span class="sd">    :type size: int</span>
<span class="sd">    :param seed: Seed of the random number generator.</span>
<span class="sd">    :type seed: Optional[int]</span>
<span class="sd">    :return: Points sampled inside the oriented box.</span>
<span class="sd">    :rtype: np.ndarray</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[-2.65908417, 1.66316594, -12.05967958], [0.0459558, 1.72705225, -5.76867598], [ -6.27471812,   1.66093731,  -3.02014327], [-9.10951204, 1.59325844, -9.76566801], [-2.56569358, -1.59892799, -12.08053818], [0.1378323 , -1.63325758, -5.80021574], [-6.33750632, -1.6103617 , -2.9846542], [-9.17057479, -1.57383548, -9.73196329], [-4.49166262, 0.0285039, -7.65144228]])</span>
<span class="sd">        &gt;&gt;&gt; pcd = o3d.geometry.PointCloud()</span>
<span class="sd">        &gt;&gt;&gt; pcd.points = o3d.utility.Vector3dVector(points)</span>
<span class="sd">        &gt;&gt;&gt; oriented_bounding_box = pcd.get_oriented_bounding_box()</span>
<span class="sd">        &gt;&gt;&gt; points_in_oriented_box = pointcloud.get_points_uniform_sampled_inside_oriented_box(oriented_bounding_box, size = 2, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; for point in points_in_oriented_box: print (point)</span>
<span class="sd">        [-4.82733002 -1.33178146 -3.41651872]</span>
<span class="sd">        [-6.26834682  1.62343098 -6.66719078]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">x_coords</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">box</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">y_coords</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">box</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">z_coords</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">box</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">x_coords</span> <span class="o">=</span> <span class="n">x_coords</span> <span class="o">-</span> <span class="n">box</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">y_coords</span> <span class="o">=</span> <span class="n">y_coords</span> <span class="o">-</span> <span class="n">box</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">z_coords</span> <span class="o">=</span> <span class="n">z_coords</span> <span class="o">-</span> <span class="n">box</span><span class="o">.</span><span class="n">extent</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">w_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
    <span class="n">affine_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">box</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">center</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])))</span>
    <span class="n">all_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">row_stack</span><span class="p">([</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">,</span> <span class="n">z_coords</span><span class="p">,</span> <span class="n">w_coords</span><span class="p">]))</span>
    <span class="n">all_points_transformed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">affine_matrix</span> <span class="o">*</span> <span class="n">all_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">all_points_transformed</span></div>


<div class="viewcode-block" id="get_points_uniform_sampled_inside_axis_aligned_box"><a class="viewcode-back" href="../api/pointcloud.get_points_uniform_sampled_inside_axis_aligned_box.html#pointcloud.get_points_uniform_sampled_inside_axis_aligned_box">[docs]</a><span class="k">def</span> <span class="nf">get_points_uniform_sampled_inside_axis_aligned_box</span><span class="p">(</span><span class="n">min_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">min_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                                                       <span class="n">min_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an array of points inside the axis-aligned box delimited by the input parameters.</span>

<span class="sd">    :param seed:</span>
<span class="sd">    :param min_x: Minimum value of X coordinate for the box.</span>
<span class="sd">    :type min_x: float</span>
<span class="sd">    :param max_x: Maximum value of X coordinate for the box.</span>
<span class="sd">    :type max_x: float</span>
<span class="sd">    :param min_y: Minimum value of Y coordinate for the box.</span>
<span class="sd">    :type min_y: float</span>
<span class="sd">    :param max_y: Maximum value of Y coordinate for the box.</span>
<span class="sd">    :type max_y: float</span>
<span class="sd">    :param min_z: Minimum value of Z coordinate for the box.</span>
<span class="sd">    :type min_z: float</span>
<span class="sd">    :param max_z: Maximum value of Z coordinate for the box.</span>
<span class="sd">    :type max_z: float</span>
<span class="sd">    :param size: Number of points to sample, default to 1.</span>
<span class="sd">    :type size: int</span>
<span class="sd">    :return: Points sampled inside the box.</span>
<span class="sd">    :rtype: np.ndarray</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; A = pointcloud.get_points_uniform_sampled_inside_axis_aligned_box(0, 1, 0, 1, 0, 1, size=10, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; for point in A: print(point)</span>
<span class="sd">        [0.77395605 0.37079802 0.75808774]</span>
<span class="sd">        [0.43887844 0.92676499 0.35452597]</span>
<span class="sd">        [0.85859792 0.64386512 0.97069802]</span>
<span class="sd">        [0.69736803 0.82276161 0.89312112]</span>
<span class="sd">        [0.09417735 0.4434142  0.7783835 ]</span>
<span class="sd">        [0.97562235 0.22723872 0.19463871]</span>
<span class="sd">        [0.7611397  0.55458479 0.466721  ]</span>
<span class="sd">        [0.78606431 0.06381726 0.04380377]</span>
<span class="sd">        [0.12811363 0.82763117 0.15428949]</span>
<span class="sd">        [0.45038594 0.6316644  0.68304895]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">x_coords</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">min_x</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">max_x</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">y_coords</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">min_y</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">max_y</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="n">z_coords</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="n">min_z</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">max_z</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">,</span> <span class="n">z_coords</span><span class="p">])</span></div>

<div class="viewcode-block" id="get_pointcloud_after_substracting_point_cloud"><a class="viewcode-back" href="../api/pointcloud.get_pointcloud_after_substracting_point_cloud.html#pointcloud.get_pointcloud_after_substracting_point_cloud">[docs]</a><span class="k">def</span> <span class="nf">get_pointcloud_after_substracting_point_cloud</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span> <span class="n">substract</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span>
                                                  <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Substracts one pointcloud from another. It removes all the points of the first pointcloud that are</span>
<span class="sd">    closer than *threshold* to some point of the second pointcloud.</span>

<span class="sd">    :param pcd: Pointcloud to substract from.</span>
<span class="sd">    :type pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param substract: Pointcloud to substract.</span>
<span class="sd">    :type substract: o3d.geometry.PointCloud</span>
<span class="sd">    :param threshold: If a point of the first pointcloud is closer to some point of the second pointcloud than this value, the point is removed.</span>
<span class="sd">    :type threshold: float</span>
<span class="sd">    :return: The results after substracting the second pointcloud from the first pointcloud.</span>
<span class="sd">    :rtype: o3d.geometry.PointCloud</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; mesh_box = o3d.geometry.TriangleMesh.create_box(width=1.0, height=5.0, depth=1.0)</span>
<span class="sd">        &gt;&gt;&gt; pcd_1 = mesh_box.sample_points_uniformly(number_of_points = 10000, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; mesh_box = o3d.geometry.TriangleMesh.create_box(width=1.5, height=4.0, depth=0.5)</span>
<span class="sd">        &gt;&gt;&gt; pcd_2 = mesh_box.sample_points_uniformly(number_of_points = 10000, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; # pcd_1.paint_uniform_color([1, 0, 0])</span>
<span class="sd">        &gt;&gt;&gt; # pcd_2.paint_uniform_color([0, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; pcd_1_minus_pcd_2 = pointcloud.get_pointcloud_after_substracting_point_cloud(pcd_1, pcd_2, threshold = 0.02)</span>
<span class="sd">        &gt;&gt;&gt; pcd_1_minus_pcd_2</span>
<span class="sd">        PointCloud with 5832 points.</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([pcd_1_minus_pcd_2])</span>
<span class="sd">        &gt;&gt;&gt; pcd_2_minus_pcd_1 = pointcloud.get_pointcloud_after_substracting_point_cloud(pcd_2, pcd_1, threshold = 0.02)</span>
<span class="sd">        &gt;&gt;&gt; pcd_2_minus_pcd_1</span>
<span class="sd">        PointCloud with 4726 points.</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([pcd_2_minus_pcd_1])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">aux_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="p">[</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcd_tree</span><span class="o">.</span><span class="n">search_knn_vector_3d</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">knn</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">pcd_tree</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">KDTreeFlann</span><span class="p">(</span><span class="n">substract</span><span class="p">)</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">remaining_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span> <span class="k">if</span>
                            <span class="n">aux_func</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span>
        <span class="n">pcd_result</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
        <span class="n">pcd_result</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">remaining_points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pcd_result</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span>
    <span class="n">remaining_points_and_colors</span> <span class="o">=</span> <span class="p">[(</span><span class="n">point</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span><span class="p">,</span> <span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span> <span class="k">if</span>
                                   <span class="n">aux_func</span><span class="p">(</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span>
    <span class="n">remaining_points</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">remaining_points_and_colors</span><span class="p">]</span>
    <span class="n">remaining_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">remaining_points_and_colors</span><span class="p">]</span>
    <span class="n">pcd_result</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">pcd_result</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">remaining_points</span><span class="p">))</span>
    <span class="n">pcd_result</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">remaining_colors</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pcd_result</span></div>

<div class="viewcode-block" id="get_line_set_from_cuboid_points"><a class="viewcode-back" href="../api/pointcloud.get_line_set_from_cuboid_points.html#pointcloud.get_line_set_from_cuboid_points">[docs]</a><span class="k">def</span> <span class="nf">get_line_set_from_cuboid_points</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
                                    <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineSet</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the set of lines corresponding to a cuboid.</span>

<span class="sd">    :param points: The points that delimit the cuboid. These points are supposed to be two opposite faces, first the four of one face and then the corresponding points in the other face. The points of a face are given in clockwise or counterclockwise order.</span>
<span class="sd">    :type points: Iterable[Iterable[float]]</span>
<span class="sd">    :param color: Color of the lines, defaults to red, parameter value is (1, 0, 0).</span>
<span class="sd">    :type color: Optional[Tuple[float, float, float]]</span>
<span class="sd">    :return: A set of lines that draw a cuboid.</span>
<span class="sd">    :rtype: o3d.geometry.LineSet</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; points = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]]</span>
<span class="sd">        &gt;&gt;&gt; line_set = pointcloud.get_line_set_from_cuboid_points(points, color = (0, 1, 0))</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([line_set])</span>
<span class="sd">        &gt;&gt;&gt; line_set</span>
<span class="sd">        LineSet with 12 lines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">))]</span>
    <span class="n">line_set</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">LineSet</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">points</span><span class="p">),</span>
                                    <span class="n">lines</span><span class="o">=</span><span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector2iVector</span><span class="p">(</span><span class="n">lines</span><span class="p">))</span>
    <span class="n">line_set</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">line_set</span></div>

<div class="viewcode-block" id="create_pointcloud_plane_from_four_points_and_thickness"><a class="viewcode-back" href="../api/pointcloud.create_pointcloud_plane_from_four_points_and_thickness.html#pointcloud.create_pointcloud_plane_from_four_points_and_thickness">[docs]</a><span class="k">def</span> <span class="nf">create_pointcloud_plane_from_four_points_and_thickness</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="n">thickness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
                                                           <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                                           <span class="n">color</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a pointcloud from four coplanar points and some thickness. The final thickness is twice such</span>
<span class="sd">    thickness parameter.</span>

<span class="sd">    :param points: Four coplanar points.</span>
<span class="sd">    :type points: Iterable[Iterable[float]]</span>
<span class="sd">    :param thickness: The thickness of the pointcloud for each side of the plane.</span>
<span class="sd">    :type thickness: float</span>
<span class="sd">    :param size: Number of points in the resulting pointcloud.</span>
<span class="sd">    :type size: int</span>
<span class="sd">    :param seed: Seed of the random number generator.</span>
<span class="sd">    :type seed: Optional[int]</span>
<span class="sd">    :param color: Color of the lines, defaults to red, parameter value is (1, 0, 0).</span>
<span class="sd">    :type color: Optional[Tuple[float, float, float]]</span>
<span class="sd">    :return: A pointcloud centered in the plane defined by the input points and with thickness twice the parameter.</span>
<span class="sd">    :rtype: o3d.geometry.PointCloud</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; points = [[5, 0, 0], [5, 1, 0], [6, 1, 0], [6, 0, 0]]</span>
<span class="sd">        &gt;&gt;&gt; pcd = pointcloud.create_pointcloud_plane_from_four_points_and_thickness(points, seed = 42, color=(0, 1, 0))</span>
<span class="sd">        &gt;&gt;&gt; pcd.points[0]</span>
<span class="sd">        array([5.72072839, 0.77395605, 0.02407728])</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([pcd])</span>
<span class="sd">        &gt;&gt;&gt; points = np.array([[-2.65908417, 1.66316594, -12.05967958], [0.0459558, 1.72705225, -5.76867598], [-6.27471812, 1.66093731, -3.02014327], [-9.10951204, 1.59325844, -9.76566801]])</span>
<span class="sd">        &gt;&gt;&gt; pcd = pointcloud.create_pointcloud_plane_from_four_points_and_thickness(points, size = 300000, seed = 42, color=(0, 1, 0))</span>
<span class="sd">        &gt;&gt;&gt; pcd.points[0]</span>
<span class="sd">        array([-2.81447494,  1.69442252, -5.9641852 ])</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([pcd])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># we need to find four points over and under the quadrilateral, in order to give thickness;</span>
    <span class="c1"># these points are computed as normal * thickness from the points.</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
    <span class="n">real_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">normal_vector</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
    <span class="n">normal_vector</span> <span class="o">=</span> <span class="n">real_vector</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">real_vector</span><span class="p">)</span>
    <span class="n">one_direction_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">item</span> <span class="o">*</span> <span class="n">thickness</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">normal_vector</span><span class="p">])</span>
    <span class="c1"># print(one_direction_vector)</span>
    <span class="n">new_points_above</span> <span class="o">=</span> <span class="p">[</span><span class="n">one_direction_vector</span> <span class="o">+</span> <span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
    <span class="n">new_points_above</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">new_points_above</span><span class="p">]</span>
    <span class="n">new_points_below</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">one_direction_vector</span> <span class="o">+</span> <span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
    <span class="n">new_points_below</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">new_points_below</span><span class="p">]</span>
    <span class="n">new_points</span> <span class="o">=</span> <span class="n">new_points_above</span> <span class="o">+</span> <span class="n">new_points_below</span>
    <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span><span class="p">]</span>
    <span class="n">all_points</span> <span class="o">=</span> <span class="n">points</span> <span class="o">+</span> <span class="n">new_points</span>
    <span class="c1"># print(all_points)</span>
    <span class="n">pcd</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">pcd</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">all_points</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">get_pointcloud_uniform_sample_inside_convex_hull_of_pointcloud</span><span class="p">(</span><span class="n">pcd</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_pointcloud_negative_of_pointcloud"><a class="viewcode-back" href="../api/pointcloud.get_pointcloud_negative_of_pointcloud.html#pointcloud.get_pointcloud_negative_of_pointcloud">[docs]</a><span class="k">def</span> <span class="nf">get_pointcloud_negative_of_pointcloud</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
                                          <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                                          <span class="n">color</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the negative of a pointcloud, sampling inside it and removing all the generated points that are close to the original pointcloud.</span>

<span class="sd">    :param pcd: Pointcloud.</span>
<span class="sd">    :param pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param size: Number of points in the resulting pointcloud.</span>
<span class="sd">    :type size: int</span>
<span class="sd">    :param threshold: If a point of the first pointcloud is closer to some point of the second pointcloud than this value, the point is removed.</span>
<span class="sd">    :type threshold: float</span>
<span class="sd">    :param seed: Seed of the random number generator.</span>
<span class="sd">    :type seed: Optional[int]</span>
<span class="sd">    :param color: Color of the lines, defaults to red, parameter value is (1, 0, 0).</span>
<span class="sd">    :type color: Optional[Tuple[float, float, float]]</span>
<span class="sd">    :return: The negative of a pointcloud, sampling inside it and removing all the generated points that are close to the original pointcloud.</span>
<span class="sd">    :rtype: o3d.geometry.PointCloud</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; # import os</span>
<span class="sd">        &gt;&gt;&gt; # home_dir = os.getenv(&quot;HOME&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # pcd = o3d.io.read_point_cloud(home_dir + &quot;/Github/Lantegi/Code/Open3D/gui/skull.ply&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pcd = o3d.io.read_point_cloud(&quot;Code/Open3D/gui/skull.ply&quot;)</span>
<span class="sd">        &gt;&gt;&gt; negative_pcd = pointcloud.get_pointcloud_negative_of_pointcloud(pcd, size = 10000, seed = 42, threshold = 5)</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([negative_pcd])</span>
<span class="sd">        &gt;&gt;&gt; negative_pcd.points[0]</span>
<span class="sd">        array([  1.92245891, -90.53361029, -79.71444622])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pcd_inside</span> <span class="o">=</span> <span class="n">get_pointcloud_uniform_sample_inside_convex_hull_of_pointcloud</span><span class="p">(</span><span class="n">pcd</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span><span class="p">)</span>
    <span class="c1"># o3d.visualization.draw_geometries([pcd_inside])</span>
    <span class="k">return</span> <span class="n">get_pointcloud_after_substracting_point_cloud</span><span class="p">(</span><span class="n">pcd_inside</span><span class="p">,</span> <span class="n">pcd</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_pointcloud_projection_onto_plane_of_pointcloud"><a class="viewcode-back" href="../api/pointcloud.get_pointcloud_projection_onto_plane_of_pointcloud.html#pointcloud.get_pointcloud_projection_onto_plane_of_pointcloud">[docs]</a><span class="k">def</span> <span class="nf">get_pointcloud_projection_onto_plane_of_pointcloud</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span>
                                                       <span class="n">plane</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">plane</span><span class="o">.</span><span class="n">PlaneIndoor</span><span class="p">],</span> <span class="n">percentage</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                                                       <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a projection of a pointcloud into a plane. The number of points of the projection is **percentage** points of the original pointcloud.</span>

<span class="sd">    :param pcd: Pointcloud.</span>
<span class="sd">    :param pcd: o3d.geometry.PointCloud</span>
<span class="sd">    :param plane: Plane.</span>
<span class="sd">    :type plane: Type[PlaneIndoor]</span>
<span class="sd">    :param percentage: Percentage of points with respect to the original pointcloud in the projected pointcloud.</span>
<span class="sd">    :type percentage: float</span>
<span class="sd">    :param seed: Seed of the random number generator.</span>
<span class="sd">    :type seed: Optional[int]</span>
<span class="sd">    :return: The projection of a pointcloud into a plane.</span>
<span class="sd">    :rtype: o3d.geometry.PointCloud</span>

<span class="sd">    :Example:</span>

<span class="sd">    ::</span>

<span class="sd">        &gt;&gt;&gt; import pointcloud</span>
<span class="sd">        &gt;&gt;&gt; import plane</span>
<span class="sd">        &gt;&gt;&gt; import open3d as o3d</span>
<span class="sd">        &gt;&gt;&gt; # import os</span>
<span class="sd">        &gt;&gt;&gt; # home_dir = os.getenv(&quot;HOME&quot;)</span>
<span class="sd">        &gt;&gt;&gt; # pcd = o3d.io.read_point_cloud(home_dir + &quot;/Github/Lantegi/Code/Open3D/gui/skull.ply&quot;)</span>
<span class="sd">        &gt;&gt;&gt; pcd = o3d.io.read_point_cloud(&quot;Code/Open3D/gui/skull.ply&quot;)</span>
<span class="sd">        &gt;&gt;&gt; plane = plane.PlaneIndoor((1, 2, 3, 4))</span>
<span class="sd">        &gt;&gt;&gt; projection = pointcloud.get_pointcloud_projection_onto_plane_of_pointcloud(pcd, plane, percentage = 0.3, seed = 42)</span>
<span class="sd">        &gt;&gt;&gt; # o3d.visualization.draw_geometries([projection])</span>
<span class="sd">        &gt;&gt;&gt; projection.points[0]</span>
<span class="sd">        array([ 29.08498429, -89.64099743,  48.73233686])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_pcd</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">new_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">new_colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">how_many</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">*</span> <span class="n">percentage</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">)),</span> <span class="n">size</span> <span class="o">=</span> <span class="n">how_many</span><span class="p">,</span> <span class="n">replace</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">new_point</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">get_point_projection_onto_plane</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="n">new_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_point</span><span class="p">)</span>
        <span class="n">new_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
    <span class="n">new_pcd</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">new_points</span><span class="p">)</span>
    <span class="n">new_pcd</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">new_colors</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_pcd</span></div>

<span class="c1">#@profile</span>
<div class="viewcode-block" id="cut_into_disjoint_slices_by_axis_pointcloud"><a class="viewcode-back" href="../api/pointcloud.cut_into_disjoint_slices_by_axis_pointcloud.html#pointcloud.cut_into_disjoint_slices_by_axis_pointcloud">[docs]</a><span class="k">def</span> <span class="nf">cut_into_disjoint_slices_by_axis_pointcloud</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span>
                                                <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">)</span> <span class="o">-&gt;</span> \
        <span class="n">List</span><span class="p">[</span><span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">]:</span>
    <span class="n">maxs</span> <span class="o">=</span> <span class="n">pcd</span><span class="o">.</span><span class="n">get_max_bound</span><span class="p">()</span>
    <span class="n">mins</span> <span class="o">=</span> <span class="n">pcd</span><span class="o">.</span><span class="n">get_min_bound</span><span class="p">()</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">mins</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="n">mins</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">min_z</span> <span class="o">=</span> <span class="n">mins</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">max_z</span> <span class="o">=</span> <span class="n">maxs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">low_axis</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">min_x</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">high_axis</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_x</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">low_axis</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">min_y</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">high_axis</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_y</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">low_axis</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">min_z</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">high_axis</span> <span class="o">=</span> <span class="n">step</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">max_z</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span>
    <span class="n">num_slices</span> <span class="o">=</span> <span class="nb">round</span><span class="p">((</span><span class="n">high_axis</span> <span class="o">-</span> <span class="n">low_axis</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">l_points_slices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">l_colors_slices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_slices</span><span class="p">):</span>
        <span class="n">l_points_slices</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">l_colors_slices</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">np_pcd_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">which_slices</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">np_pcd_points</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">low_axis</span><span class="p">)</span> <span class="o">/</span> <span class="n">step</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">counter_slices</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">which_slices</span><span class="p">)</span>
    <span class="n">list_slice_values_ordered</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">low_axis</span> <span class="o">+</span> <span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">counter_slices</span><span class="o">.</span><span class="n">most_common</span><span class="p">()])</span>
    <span class="c1"># return which_slices, counter_slices, list_slice_values_ordered</span>
    <span class="k">return</span> <span class="n">which_slices</span><span class="p">,</span> <span class="n">list_slice_values_ordered</span></div>

<div class="viewcode-block" id="crop"><a class="viewcode-back" href="../api/pointcloud.crop.html#pointcloud.crop">[docs]</a><span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="n">pcd</span><span class="p">,</span> <span class="n">cuboid_points</span><span class="p">):</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">cuboid_points</span><span class="p">)</span>
    <span class="n">oriented_bounding_box</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">OrientedBoundingBox</span><span class="o">.</span><span class="n">create_from_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">point_cloud_crop</span> <span class="o">=</span> <span class="n">pcd</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">oriented_bounding_box</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">point_cloud_crop</span><span class="p">,</span> <span class="n">oriented_bounding_box</span></div>

<span class="c1">#@profile</span>
<div class="viewcode-block" id="count_points_in_voxel_in_x_and_z"><a class="viewcode-back" href="../api/pointcloud.count_points_in_voxel_in_x_and_z.html#pointcloud.count_points_in_voxel_in_x_and_z">[docs]</a><span class="k">def</span> <span class="nf">count_points_in_voxel_in_x_and_z</span><span class="p">(</span><span class="n">pcd</span><span class="p">:</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.02</span><span class="p">,</span>
                                     <span class="n">percentile</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">95</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">round_down</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">pcd_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
    <span class="n">pcd_colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pcd</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span>
    <span class="n">pcd_points_x_z</span> <span class="o">=</span> <span class="n">pcd_points</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]</span>
    <span class="c1"># voxel_coords = np.floor(pcd_points_x_z / edge) * edge</span>
    <span class="c1"># points_in_voxels = Counter(tuple(map(tuple, voxel_coords)))</span>
    <span class="c1"># voxel_coords2 = np.floor(pcd_points_x_z / edge)</span>
    <span class="c1"># points_in_voxels2 = Counter(tuple(map(tuple, voxel_coords2)))</span>
    <span class="n">voxel_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">pcd_points_x_z</span> <span class="o">/</span> <span class="n">edge</span><span class="p">)</span>
    <span class="n">voxel_coords</span> <span class="o">=</span> <span class="n">voxel_coords</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">voxel_coords</span> <span class="o">=</span> <span class="n">voxel_coords</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">voxel_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">voxel_coords</span> <span class="o">=</span> <span class="n">voxel_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">factor</span> <span class="o">+</span> <span class="n">voxel_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">points_in_voxels</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">voxel_coords</span><span class="p">)</span>
    <span class="c1"># for point in zip(pcd_points, voxel_coords):</span>
    <span class="c1">#     x_coord = round_down(point[0], edge)</span>
    <span class="c1">#     z_coord = round_down(point[2], edge)</span>
    <span class="c1">#     points_in_voxels[(x_coord, z_coord)] += 1</span>
    <span class="n">threshold_for_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">points_in_voxels</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">percentile</span><span class="p">)</span>
    <span class="c1"># threshold_for_points = np.percentile(list(points_in_voxels3.values()), percentile)</span>
    <span class="n">good_keys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">points_in_voxels</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="n">threshold_for_points</span><span class="p">])</span>
    <span class="n">good_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">voxel_coords</span><span class="p">,</span> <span class="n">good_keys</span><span class="p">)</span>
    <span class="n">new_pcd</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">PointCloud</span><span class="p">()</span>
    <span class="n">new_pcd</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">pcd_points</span><span class="p">[</span><span class="n">good_mask</span><span class="p">])</span>
    <span class="n">new_pcd</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">utility</span><span class="o">.</span><span class="n">Vector3dVector</span><span class="p">(</span><span class="n">pcd_colors</span><span class="p">[</span><span class="n">good_mask</span><span class="p">])</span>
    <span class="c1"># new_points = list()</span>
    <span class="c1"># new_colors = list()</span>
    <span class="c1"># for point, color in zip(pcd.points, pcd.colors):</span>
    <span class="c1">#     x_coord = round_down(point[0], edge)</span>
    <span class="c1">#     z_coord = round_down(point[2], edge)</span>
    <span class="c1">#     if points_in_voxels[(x_coord, z_coord)] &gt;= threshold_for_points:</span>
    <span class="c1">#         new_points.append([point[0], point[1], point[2]])</span>
    <span class="c1">#         new_colors.append([color[0], color[1], color[2]])</span>
    <span class="c1"># new_pcd.points = o3d.utility.Vector3dVector(new_points)</span>
    <span class="c1"># new_pcd.colors = o3d.utility.Vector3dVector(new_colors)</span>
    <span class="k">return</span> <span class="n">points_in_voxels</span><span class="p">,</span> <span class="n">new_pcd</span></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">indoor3d 0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pointcloud</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, RSAIT.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>